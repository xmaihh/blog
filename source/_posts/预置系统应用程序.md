---
title: 预置系统应用程序
date: 2018-06-27 15:45:01
categories: Android Framework
tags: [Android]
toc: false
description: I loved the way a photo could capture a moment before it was gone. 
---
我们需要在系统安装好之后首次启动系统就存在我们的应用程序，而不需要开机之后再次安装，这样就需要考虑进行预置APP（应用），预置还有一个作用，就是有的程序被卸载之后，在系统执行双清操作（清空数据，恢复出厂）之后是可以恢复的。
对预置应用我们可以简单做个分类： 
按照是否可以卸载可以分为不可卸载的和可卸载的；可卸载的又可以分为恢复出厂设置时能恢复的和不能恢复的；按照有没有APK源码又可以分为源码预置还是只是预置APK。

对于预置应用，我们一般做的是没有源码的APP（单个APK文件，相对简单，更符合需求），因此重点在预置无源码的应用程序上。

下图是几个常用的apk安装目录（参考-<source>/out/target/product/xxx/system/app）：

目录 | 描述
---- | ---
/system/framework    | 用于存放资源型应用（系统框架）
/system/app |  用于存放系统应用，不能卸载
/system/priv-app  | Android4.4+新增，系统【核心】应用存放路径（最高权限）
/vendor/app   |  用于存放厂商应用，可以卸载，恢复出厂时恢复
/data/app    |  用于存放用户应用，可以卸载，恢复出厂不能恢复
/data/app-private  |  Android4.4+新增，受DRM保护的应用存放路径

### 方法
声明：以预置一个名为 Test 的APK为例
##### 一、如何将带源码的APK预置进系统，应用不能卸载？（了解） 
1. 在 packages/apps 下面以需要预置的 APK的 名字创建一个新文件夹。 
2. 将 Test APK的Source code 拷贝到 Test 文件夹下，删除 /bin 和 /gen 目录。 
3. 在 Test 目录下创建一个名为 Android.mk的文件，内容如下：
```
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES := $(call all-subdir-Java-files)
LOCAL_PACKAGE_NAME := Test
include $(BUILD_PACKAGE)
```
4. 打开文件 device/xxx/common/device.mk，将 Test 添加到 PRODUCT_PACKAGES 里面。
```
PRODUCT_PACKAGES += Test
```
>说明：其中 xxx 代表代表厂商或者平台方名字。 
5. 重新 build 整个工程 
编译成功后，Test.apk 会預置到/system/app底下

##### 二、如何将无源码的 APK 预置进系统，应用不能卸载？（重要）

1. 在 packages/apps 下面以需要预置的 APK 名字创建文件夹。 
2. 将 Test.apk 放到 packages/apps/Test 下面。 
3. 在 packages/apps/Test 下面创建文件 Android.mk，文件内容如下：
```
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
# Module name should match apk name to be installed
LOCAL_MODULE := Test
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES := $(LOCAL_MODULE).apk
LOCAL_MODULE_CLASS := APPS
LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)
LOCAL_PREBUILT_JNI_LIBS:= \
@lib/armeabi/libtest.so  \
@lib/armeabi/libtest2.so 
LOCAL_CERTIFICATE := PRESIGNED
include $(BUILD_PREBUILT)
```
>注意1： 
若无so，删除LOCAL_PREBUILT_JNI_LIBS 
若有so，使用LOCAL_PREBUILT_JNI_LIBS列出所有so的路径，不要忘记使用@。@标识符会将apk中的so抽离出来build进apk同级目录下的lib文件夹中。 
若apk支持不同 CPU 类型的so，针对so的部分的处理（即将和TARGET_ARCH对应的so抽离出来）
```
Ifeq ($(TARGET_ARCH),arm)
LOCAL_PREBUILT_JNI_LIBS := \
@lib/armeabi-v7a/xxx.so/
@ lib/armeabi-v7a/xxxx.so
else ifeq ($(TARGET_ARCH),x86)
LOCAL_PREBUILT_JNI_LIBS := \
@lib/x86/xxx.so
else ifeq ($(TARGET_ARCH),arm64)
LOCAL_PREBUILT_JNI_LIBS := \
@lib/armeabi-v8a/xxx.so
…
```
>注意2： 
如果App使用System Level的permission，需要預置到/system/priv-app底下 (原在/system/app)。 
此时修改Android.mk，增加LOCAL_PRIVILEGED_MODULE := true，以声明app需要放在/system/priv-app下。 

>注意3： 
若需要apk作为32bit的apk运行，则需要在Android.mk中定义 LOCAL_MULTILIB :=32。 
4. 打开文件 device/xxx/common/device.mk 将 Test 添加到 PRODUCT_PACKAGES 里面。
```
PRODUCT_PACKAGES += Test
```
说明：其中 xxx 代表代表厂商或者平台方名字。 
5. 重新 build 整个工程 
编译成功后，Test.apk 会預置到/system/app底下。

##### 三、如何预置APK使得用户可以卸载，恢复出厂设置时不能恢复？ 
1. 在 packages/apps 下面以需要预置的 APK 名字创建文件夹。 
2. 将 Test.apk 放到 packages/apps/Test 下面。 
3. 在 packages/apps/Test 下面创建文件 Android.mk，文件内容如下：
```
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
# Module name should match apk name to be installed
LOCAL_MODULE := Test
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES := $(LOCAL_MODULE).apk
LOCAL_MODULE_CLASS := APPS
LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)
# LOCAL_PRIVILEGED_MODULE := true
LOCAL_MODULE_PATH := $(TARGET_OUT_DATA_APPS)
LOCAL_CERTIFICATE := PRESIGNED
include $(BUILD_PREBUILT)
```
>注意： 
这个比不能卸载的多了一句 LOCAL_MODULE_PATH := $(TARGET_OUT_DATA_APPS)
4. 打开文件 device/mediatek/common/device.mk，将 Test 添加到 PRODUCT_PACKAGES 里面。
```
PRODUCT_PACKAGES += Test
```
5. 重新 build 整个工程
##### 四、如何预置APK使得用户可以卸载，并且恢复出厂设置时能够恢复？ 
1. 在 vendor/xxx/proprietary/binary/3rd-party/free 下面以需要预置的 APK 名字创建文件夹。 
2. 将 Test.apk 放入vendor/xxx/proprietary/binary/3rd-party/free/Test 下面。 
3. 在 vendor/xxx/proprietary/binary/3rd-party/free/Test 下面创建文件 Android.mk，文件内容如下
```
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
# Module name should match apk name to be installed
LOCAL_MODULE := Test
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES := $(LOCAL_MODULE).apk
LOCAL_MODULE_CLASS := APPS
LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)
LOCAL_MODULE_PATH := $(TARGET_OUT)/vendor/operator/app
LOCAL_CERTIFICATE := PRESIGNED
include $(BUILD_PREBUILT)
```
>注意： 
这个比不能卸载的多了一句 LOCAL_MODULE_PATH := $(TARGET_OUT)/vendor/operator/app
4. 打开文件device/xxx/common/device.mk 将 Test 添加到 PRODUCT_PACKAGES 里面。
```
PRODUCT_PACKAGES += Test
```
3. 然后重新build整个工程。
