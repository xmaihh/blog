---
title: 高字节与低字节、高地址与低地址、大端模式与小端模式、网络字节顺序与主机字节顺序
date: 2019-03-06 14:10:54
categories: C/C++
tags: [Jni,C/C++]
toc: true
description: Never trouble trouble till trouble troubles you.
---

- 字节序，顾名思义字节的顺序，再多说两句就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数据当然就无需谈顺序的问题了)。
- 低地址、高地址：内存地址可以对应十六进制的数值，值大的为高地址，否则为低地址。
- 网络字节顺序NBO(Network Byte Order):按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。
- 主机字节顺序HBO(Host Byte Order):不同的机器HBO不相同，与CPU设计有关计算机数据存储有两种字节优先顺序：高位字节优先和低位字节优先。在网络上数据以高位字节优先顺序在网络上传输，所以对于在内部是以低位字节优先方式存储数据的机器，在网络上传输数据时就需要进行转换。

# 高字节与低字节

字节顺序是指占内存多于一个字节类型的数据在内存中的存放顺序，通常有小端、大端两种字节顺序。
小端字节序指低字节数据存放在内存低地址处，高字节数据存放在内存高地址处；
大端字节序是高字节数据存放在低地址处，低字节数据存放在高地址处。

- 计算机的数值应视为连续若干个二进制位的集合
- 所谓高、低字节就是此集合中位地址高/低的二进制位集合
- 例如定义一个unsigned short型变量在0x1234 5678，那么这个变量的地址就是0x1234 5678，占用0x1234 5678与0x1234 5679两字节存储空间，其中0x1234 5678是低字节、0x1234 5679是高字节
- 一个16进制数有两个字节组成，例如：A9。高字节就是指16进制数的前8位（权重高的8位），如上例中的A。低字节就是指16进制数的后8位（权重低的8位），如上例中的9

举个栗子，按平时书写习惯，从左到右是高位到地位的顺序，假设有一张1000块的钞票，从左往右写就是`1000`，1所在的位置为高位，想象一下如果把`1`写在低位，就是`0001`，那样你得到的就是1块钱了。

# 高地址与低地址

在内存中，栈是向下生长的,以char arr[4]为例，（因为char类型数据只有一个字节，不存在字节序的问题）依次输出每个元素的地址，可以发现，arr[0]的地址最低，arr[3]的地址最高，如图:

![高地址与低地址 char举例](https://i.loli.net/2019/03/06/5c7f8954dea03.png)

## 高低位
接下来看什么是高低位

 给一个十进制整数，`123456`，很明显左边的是高位，右边的是低位。计算机也是这样认为的。给一个16进制数，`0x12345678`，以字节为单位，从高位到低位依次是 `0x12`、`0x34`、`0x56`、`0x78`。

 接下来将高地地址和高低位对应。

     一个整形占4个字节，给一个整形数据0x12345678，如果是大端存储，存储格式如下:

![大端存储](https://i.loli.net/2019/03/06/5c7f8e88da55d.png)

如果是小端存储，存储格式如下:

![小端存储](https://i.loli.net/2019/03/06/5c7f9034ba334.png)

## 如何判断当前系统是大端还是小端呢？

最简单地来说，我们可以用 1 为例，1在栈中存储的大小端格式分别如下图所示:

![](https://i.loli.net/2019/03/06/5c7f934a6fbb2.png)

如果我们可以得到 1 在内存中存储的第一个字节，那么我们就可以知道当前系统是大端存储还是小端存储了。

# 大端模式与小端模式

## 为什么会有大小端？

 这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于 8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择。

## 大小端是什么?

![大小端是什么](https://i.loli.net/2019/03/06/5c7f95c739fca.png)

- 所谓的大端模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；

- 所谓的小端模式，是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。

大端方式将高位存放在低地址，小端方式将低位存放在低地址。采用大端方式 进行数据存放符合人类的正常思维，而采用小端方式进行数据存放利于计算机处理。

## 大小端分别的优势

- 小端模式(Little-Endian)：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。

- 大端模式(Big-Endian)：符号位的判定固定为第一个字节，容易判断正负。

## 大小端的判断

简单介绍两种方法
方法1：

```c
#include <stdio.h>
union hehe
{
    int a;
    char c;
}un;
int main ()
{
    un.a = 1;
    if(un.c == 1)
    {
        printf("小端存储\n");
    }
    else
    {
        printf("大端存储\n");
    }
    return 0;
}
```
方法2：

```c
#include <stdio.h>
int main ()
{
    int a = 1;
    char *p = (char *)&a;
    if(*p == 1)
    {
        printf("小端存储\n");
    }
    else
    {
        printf("大端存储\n");
    }
    return 0;
}
```

# 网络字节序与主机字节序

- 网络字节顺序NBO（Network Byte Order）：按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。

- 主机字节顺序（HBO，Host Byte Order）：不同的机器HBO不相同，与CPU设计有关计算机数据存储有两种字节优先顺序：高位字节优先和低位字节优先。

Internet上数据以高位字节优先顺序在网络上传输，所以对于在内部是以低位字节优先方式存储数据的机器，在Internet上传输数据时就需要进行转换。

# Reference

[https://blog.csdn.net/qq_27384769/article/details/80700320](https://blog.csdn.net/qq_27384769/article/details/80700320)
[https://blog.csdn.net/Dawn_sf/article/details/54565487](https://blog.csdn.net/Dawn_sf/article/details/54565487)
[https://blog.csdn.net/liubing8609/article/details/82054745](https://blog.csdn.net/liubing8609/article/details/82054745)
[https://blog.csdn.net/ywgdk/article/details/52788447](https://blog.csdn.net/ywgdk/article/details/52788447)
